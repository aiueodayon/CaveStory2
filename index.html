<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <title>Cave Story Web</title>
    <meta name="description" content="Cave Story (Doukutsu Monogatari) - 100% playable in your browser!">
    <meta content="https://vinmannie.github.io/CaveStory/" property="og:url" />
    <meta content="https://vinmannie.github.io/CaveStory/cavestory.png" property="og:image" />
    <meta name="theme-color" content="#6f9cd6" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Pixel-style font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
      body {
        margin: 0;
        padding: 0;
        background: linear-gradient(180deg, #0a0a0a 0%, #1a1a1a 100%);
        color: #eee;
        font-family: 'Press Start 2P', monospace;
        text-align: center;
      }

      h1, h4 {
        margin: 0.5em 0;
        text-shadow: 2px 2px 0 #000;
      }

      h1 { color: #6f9cd6; font-size: 1.6em; }
      h4 { color: #aaa; font-size: 0.9em; }

      .spinner {
        height: 50px;
        width: 50px;
        margin: 20px auto;
        animation: rotation 0.8s linear infinite;
        border: 10px solid #0996f0;
        border-top-color: #6400c8;
        border-radius: 50%;
      }

      @keyframes rotation {
        from {transform: rotate(0deg);}
        to {transform: rotate(360deg);}
      }

      .emscripten {
        display: block;
        margin: 0 auto;
      }

      canvas.emscripten {
        border: 2px solid #333;
        background-color: black;
        image-rendering: pixelated;
        box-shadow: 0 0 15px rgba(255,255,255,0.1);
        max-width: 95vw;
      }

      button {
        background-color: #6f9cd6;
        border: none;
        color: white;
        font-family: 'Press Start 2P', monospace;
        padding: 10px 20px;
        margin: 20px 5px;
        border-radius: 8px;
        cursor: pointer;
        box-shadow: 0 0 8px #6f9cd6;
        transition: all 0.2s;
      }

      button:hover {
        transform: scale(1.05);
        box-shadow: 0 0 15px #9dc9ff;
      }

      .content {
        max-width: 700px;
        margin: 2em auto;
        font-size: 0.7em;
        line-height: 1.6em;
        color: #ccc;
      }

      hr {
        width: 60%;
        border: 0;
        height: 1px;
        background: #333;
        margin: 2em auto;
      }

      /* Drag & drop visual */
      .drop-instructions {
        margin: 0.6em auto;
        font-size: 0.75em;
        color: #bcd;
      }
      .dragover {
        outline: 3px dashed #9dc9ff;
        outline-offset: 8px;
        box-shadow: 0 0 20px rgba(157,201,255,0.08);
      }

      @media screen and (max-width: 600px) {
        h1 { font-size: 1.2em; }
        h4 { font-size: 0.8em; }
        button { font-size: 0.6em; padding: 8px 15px; }
        .content { font-size: 0.6em; padding: 0 1em; }
      }
    </style>
  </head>

  <body>
    <h1><u>Cave Story</u></h1>
    <h4>Doukutsu Monogatari</h4>

    <div id="spinner" class="spinner"></div>
    <div class="emscripten" id="status">Waiting for WASM...</div>
    <progress id="progress" value="0" max="100" hidden></progress>

    <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()"></canvas>
    
    <div class="drop-instructions" id="dropInstructions">
      Drop a CSE2.wasm file onto this page (or use "Load WASM" button) to start.<br>
      Save data is persisted in the browser (IndexedDB). You can also download/upload save files below.
    </div>

    <button id="chooseWasmBtn">Load WASM file</button>
    <button onclick="goFullScreen()">Go Fullscreen</button>
    <button id="downloadSaveBtn">Download Save</button>
    <button id="clearSaveBtn">Clear Saved Data</button>

    <input type="file" id="wasmFileInput" accept=".wasm" style="display:none" />
    <input type="file" id="importSaveInput" accept="*" style="display:none" />

    <hr>

    <div class="content">
      <strong>This is a modification/archive of <br>sonicresearch.org/clownacy/cave.html.</strong>
      <p>
        This version adds a fullscreen option and ensures compatibility
        with modern browsers and network filters. Original port by Clownacy.
      </p>
    </div>

    <script>
      function goFullScreen() {
        const canvas = document.getElementById("canvas");
        if (canvas.requestFullscreen) canvas.requestFullscreen();
        else if (canvas.webkitRequestFullscreen) canvas.webkitRequestFullscreen();
        else if (canvas.mozRequestFullScreen) canvas.mozRequestFullScreen();
      }

      const statusElement = document.getElementById('status');
      const spinnerElement = document.getElementById('spinner');

      // Prepare Module early so CSE2.js can pick up Module.wasmBinary if provided.
      var Module = {
        preRun: [
          function() {
            // Mount IDBFS at /persistent and load existing saves into FS
            try {
              if (typeof FS !== 'undefined' && typeof IDBFS !== 'undefined') {
                // If FS already exists (unlikely here), mount later in onRuntimeInitialized;
              } else {
                // We will mount when FS exists (post CSE2.js load), but to be safe,
                // set a flag and do the mount when FS is available.
              }
            } catch(e) {
              console.error('preRun IDBFS setup error', e);
            }
          }
        ],
        postRun: [],
        print: (function() {
          return function(text) { console.log(text); };
        })(),
        printErr: function(text) { console.error(text); },
        canvas: (function() {
          var canvas = document.getElementById('canvas');
          canvas.addEventListener("webglcontextlost", function(e) {
            alert('WebGL context lost. Please reload the page.');
            e.preventDefault();
          }, false);
          return canvas;
        })(),
        setStatus: function(text) {
          if (!text) spinnerElement.style.display = 'none';
          else spinnerElement.style.display = '';
          statusElement.textContent = text || '';
        },
        locateFile: function(path) {
          return path;
        }
      };

      // Helper: mount IDBFS once FS is available (CSE2.js defines FS/IDBFS)
      function ensureIDBFSMounted() {
        if (typeof FS === 'undefined' || typeof IDBFS === 'undefined') return;
        try {
          if (!FS.analyzePath('/persistent').exists) {
            FS.mkdir('/persistent');
          }
          // Mount IDBFS at /persistent
          try {
            FS.mount(IDBFS, {}, '/persistent');
          } catch (e) {
            // If already mounted, ignore
          }

          Module.setStatus('Loading saved data...');
          // Load persisted files from IndexedDB to MEMFS
          FS.syncfs(true, function(err) {
            if (err) {
              console.error('syncfs load error', err);
              Module.setStatus('Failed to load saved data.');
            } else {
              console.log('Saved data loaded into /persistent');
              Module.setStatus('Saved data loaded.');
              // Optionally, create symlink from game's expected save path to /persistent
              // e.g. if game writes to "/save", link it:
              try {
                if (!FS.analyzePath('/save').exists) {
                  FS.mkdir('/save');
                }
              } catch(e){}
            }
          });
        } catch (e) {
          console.error('ensureIDBFSMounted error', e);
        }
      }

      // Save function to flush MEMFS -> IDBFS (persist)
      function persistSave(callback) {
        if (typeof FS === 'undefined' || typeof IDBFS === 'undefined') {
          if (callback) callback(new Error('FS/IDBFS unavailable'));
          return;
        }
        Module.setStatus('Saving data...');
        FS.syncfs(false, function(err) {
          if (err) {
            console.error('syncfs save error', err);
            Module.setStatus('Failed to save data.');
            if (callback) callback(err);
          } else {
            console.log('Saved to IndexedDB');
            Module.setStatus('Saved.');
            if (callback) callback(null);
          }
        });
      }

      // Download a save file (example: read a file from /persistent and download)
      function downloadSaveFile(filepath, downloadName) {
        try {
          if (typeof FS === 'undefined') {
            Module.setStatus('File system not ready');
            return;
          }
          if (!FS.analyzePath(filepath).exists) {
            Module.setStatus('No save file found: ' + filepath);
            return;
          }
          var data = FS.readFile(filepath, { encoding: 'binary' });
          var blob = new Blob([data], { type: 'application/octet-stream' });
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a');
          a.href = url;
          a.download = downloadName || 'save.dat';
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          Module.setStatus('Save downloaded');
        } catch (e) {
          console.error('download error', e);
          Module.setStatus('Failed to download save');
        }
      }

      // Import a save file (user uploads a file and we write it into /persistent)
      function importSaveFile(file, targetPath) {
        var reader = new FileReader();
        reader.onload = function(evt) {
          try {
            var data = new Uint8Array(evt.target.result);
            FS.writeFile(targetPath, data);
            persistSave(function(err) {
              if (!err) {
                Module.setStatus('Save imported and persisted.');
              }
            });
          } catch (e) {
            console.error('import write error', e);
            Module.setStatus('Failed to import save');
          }
        };
        reader.onerror = function() {
          Module.setStatus('Failed to read import file');
        };
        reader.readAsArrayBuffer(file);
      }

      Module.setStatus('Drop CSE2.wasm onto this page, or click "Load WASM file"');

      // Work-around chromium autoplay policy
      function resumeAudio() {
        if (Module?.SDL2?.audioContext?.state === 'suspended') {
          Module.SDL2.audioContext.resume();
        }
      }
      document.getElementById('canvas').addEventListener('click', resumeAudio);
      document.addEventListener('keydown', resumeAudio);

      // Dynamic script loader for CSE2.js: only load after wasmBinary has been set (from user file).
      function loadCSE2JS() {
        if (window._CSE2Loaded) return;
        window._CSE2Loaded = true;
        Module.setStatus('Starting...');
        var s = document.createElement('script');
        s.src = 'CSE2.js';
        s.async = true;
        s.onload = function() {
          Module.setStatus('Initializing...');
          // CSE2.js defines FS/IDBFS; ensure IDBFS mounted after runtime init (onRuntimeInitialized)
          // If FS is available immediately, mount now; otherwise wait a tick.
          setTimeout(ensureIDBFSMounted, 200);
          // If Emscripten runtime fires a callback, mount there as well (robust)
          if (typeof Module['onRuntimeInitialized'] === 'function') {
            var prev = Module.onRuntimeInitialized;
            Module.onRuntimeInitialized = function() {
              try { ensureIDBFSMounted(); } catch(e){}
              prev();
            };
          } else {
            Module.onRuntimeInitialized = ensureIDBFSMounted;
          }
        };
        s.onerror = function() {
          Module.setStatus('Failed to load CSE2.js');
        };
        document.body.appendChild(s);
      }

      // Handle dropped or selected wasm file
      function handleWasmFile(file) {
        if (!file) return;
        if (!file.name.toLowerCase().endsWith('.wasm')) {
          Module.setStatus('Please provide a .wasm file (CSE2.wasm).');
          return;
        }
        Module.setStatus('Reading ' + file.name + '...');
        var reader = new FileReader();
        reader.onload = function(evt) {
          var buffer = evt.target.result;
          Module.wasmBinary = new Uint8Array(buffer);
          Module.setStatus('WASM loaded locally (' + Math.round(Module.wasmBinary.length/1024) + ' KB). Starting...');
          setTimeout(loadCSE2JS, 200);
        };
        reader.onerror = function() {
          Module.setStatus('Failed to read file.');
        };
        reader.readAsArrayBuffer(file);
      }

      // Drag & Drop wiring
      (function() {
        var dropArea = document.body;
        function preventDefault(e) { e.preventDefault(); e.stopPropagation(); }

        ['dragenter','dragover','dragleave','drop'].forEach(function(evt) {
          dropArea.addEventListener(evt, preventDefault, false);
        });

        dropArea.addEventListener('dragover', function(e) {
          dropArea.classList.add('dragover');
          Module.setStatus('Drop .wasm file to start');
        });

        dropArea.addEventListener('dragleave', function(e) {
          dropArea.classList.remove('dragover');
          Module.setStatus('Awaiting WASM file');
        });

        dropArea.addEventListener('drop', function(e) {
          dropArea.classList.remove('dragover');
          var dt = e.dataTransfer;
          if (!dt) return;
          var file = dt.files && dt.files[0];
          if (file) handleWasmFile(file);
        });

        // File chooser
        var chooseBtn = document.getElementById('chooseWasmBtn');
        var fileInput = document.getElementById('wasmFileInput');
        chooseBtn.addEventListener('click', function() { fileInput.click(); });
        fileInput.addEventListener('change', function() {
          var f = fileInput.files && fileInput.files[0];
          if (f) handleWasmFile(f);
        });

        // Download save
        var downloadBtn = document.getElementById('downloadSaveBtn');
        downloadBtn.addEventListener('click', function() {
          // choose a typical path used for saves; adjust if your game uses other path
          downloadSaveFile('/persistent/save.dat', 'cavestory-save.dat');
        });

        // Clear saved data (IndexedDB)
        var clearBtn = document.getElementById('clearSaveBtn');
        clearBtn.addEventListener('click', function() {
          if (!confirm('Clear saved data stored in this browser?')) return;
          try {
            // Remove entries from IndexedDB by syncing empty folder
            if (typeof FS !== 'undefined' && typeof IDBFS !== 'undefined') {
              // Remove files in /persistent (if any) then sync
              try {
                var listing = FS.readdir('/persistent');
                listing.forEach(function(name) {
                  if (name === '.' || name === '..') return;
                  try { FS.unlink('/persistent/' + name); } catch(e){}
                });
              } catch(e){}
              FS.syncfs(false, function(err) {
                if (err) {
                  console.error('clear save error', err);
                  Module.setStatus('Failed to clear save');
                } else {
                  Module.setStatus('Saved data cleared.');
                }
              });
            } else {
              Module.setStatus('File system not ready');
            }
          } catch(e) {
            console.error('clear error', e);
            Module.setStatus('Failed to clear saved data');
          }
        });

        // Import save via hidden input
        var importInput = document.getElementById('importSaveInput');
        importInput.addEventListener('change', function() {
          var file = importInput.files && importInput.files[0];
          if (!file) return;
          // write to /persistent/save.dat (adjust target path as needed)
          importSaveFile(file, '/persistent/save.dat');
        });

        // Expose a simple import trigger via double-click on status (optional)
        statusElement.addEventListener('dblclick', function() {
          importInput.click();
        });
      })();

      // Save before unload
      window.addEventListener('beforeunload', function(e) {
        // Attempt to persist FS synchronously-ish by issuing syncfs; note this is async,
        // and browsers may not wait long â€” but it's still worth doing.
        try {
          if (typeof FS !== 'undefined' && typeof IDBFS !== 'undefined') {
            // best-effort: start saving; cannot guarantee completion before unload
            FS.syncfs(false, function(err) {
              if (err) console.error('beforeunload save error', err);
            });
            Module.setStatus('Saving before exit...');
          }
        } catch (ex) {
          console.error('beforeunload error', ex);
        }
        // No need to call preventDefault unless you want to show confirm dialog.
      });
    </script>

    <!-- CSE2.js will be injected dynamically after the user provides a .wasm file -->
  </body>
</html>
